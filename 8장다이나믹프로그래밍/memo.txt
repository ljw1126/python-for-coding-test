[다이나믹 프로그래밍] ---------- 점화식 , 탑다운 방식 
    - '메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법'
    - **이미 계산된 결과(작은 문제)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함 
    - 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식( 탑다운-하향식과 보텀업-상향식 )으로 구성됨 

    - 다이나믹 프로그래밍은 "동적 계획법"이라고 부름 
    
    ※ 일반적인 프로그래밍 분야에서 동적(Dynamic)이란 어떤 의미를 가질까요?
        > 자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 메모리르 할당하는 기법'을 의미함
        > 반면에 알고리즘의 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미없이 사용된 단어임

    * 다이나믹 프로그래밍의 조건 
      1. 최적 부분 구조 ( Optimal Substructrue )
         - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결 가능
      2. 중복되는 부분 문제 ( Overlapping Subproblem )
         - 동일한 작은 문제를 반복적으로 해결해야 함 

    * 피보나치 수열 ( 대표적인 다이나믹 프로그래밍 예시 )
      
            1,1,2,3,5,8,13,21,34,55,89, ...
      
      > 프로그래밍에서는 이러한 수열(sequence)을 '배열'이나 '리스트'를 이용해 표현함.
      > '점화식'이란 인접한 항들 사이의 관계식을 의미함 -----★★★★★
      > 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.
        An = An-1 + An-2, A1 = 1, A2 = 1
      > 점화식으로 표현가능한 경우 재귀함수로 구현 가능


      ```java
         public static int fibo(int x){
            if ( x == 1 || x == 2){
                return 1;
            }
            return fibo(x-1) + fibo(x+2);
         }

         public static void main(String[] args) {
            System.out.println(fibo(4)); //결과 3 
         }

      ```

      > 단순 재귀 함수로 피보나치 수열을 해결하면 지수 시간 복잡도 가짐(비효율적)
        >> **중복되는 부분 문제가 여러번 호출됨 (=똑같은 계산을 하게 됨)
      > 피보나치 수열의 시간복잡도 분석 // 영상 10:00
        >> 세타 표기법 θ(1.618...^N)
        >> 빅오 표기법 O(2^N)
           >>> 빅오 표기법 기준 f(30)인경우 10억이상 연산 요함 

    * 피보나치 수열의 효율적인 해법 : 다이나믹 프로그래밍 
      - 다이나믹 프로그래밍의 사용 조건을 만족하는지 확인함
        1. 최적 부분 구조 : 큰 문제를 작은 문제로 나눌 수 있습니다. 
        2. 중복되는 부분 문제 : 동일한 작은 문제를 반복적으로 해결합니다. 
    
        ∴ 피보나치 수열은 다이나믹 프로그래밍의 사용조건을 만족함 

    * 메모이제이션(Memoization) -- 탑다운방식(하향식)
      - 메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나임 
      - '한 번 계산한 결과를 메모리 공간에 메모'하는 기법
        > 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
        > 값을 기록해 놓는다는 점에서 '캐싱(Caching)'이라고 함 

    * 탑다운 vs 보텀업   -- 다이나믹 프로그래밍 구현방법 
      - 탑다운(메모이제이션) 방식은 '하향식'이라고도 하며, 보텀업 방식은 '상향식'이라고도 함 
      - 다이나믹 프로그래밍의 전형적인 형태는 보텀엄 방식임 
        > 결과 저장용 리스트는 'DP 테이블'이라고 부름 
      - 엄밀히 말하면 
        메모이제이션은 '이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미함'
        > 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아님
        > 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있음 

    ```java
         // 보텀업 방식으로 구현 
         public static long[] d = new long[100];

         public static void main(String[] args) {
             d[1] = 1;
             d[2] = 1;
             int n = 50; // 50번째 피보나치 수 계산 

             for(int i = 3 ; i <= n ; i++){
                 d[i] = d[i-1] + d[i-2];
             }

             System.out.println(d[n]); //결과 3 
         }

      ```

      > 메모이제이션 사용시 피보나치 수열 함수의 '시간 복잡도는 O(N)' 입니다. // 선형시간 알고리즘 


      * 다이나믹 프로그래밍 vs 분할정복  // 영상 20 : 00 이후 보기 