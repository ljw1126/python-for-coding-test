"""
[문제설명]
- 동빈이는 N x M 크기의 직사각형 형태의 미로에 갇혔습니다. 미로에는 여러 마리의 괴물이 있어 
  이를 피해 탈출해야 합니다. 
- 동빈이의 위치는 (1,1)이며 미로의 출구는 (N,M)의 위치에 존재하며 한 번에 한 칸씩 이동할 수 
  있습니다. 이때 괴물이 있는 부분은 0으로, 괴물이 없는 부분은 1로 표시되어 있습니다. 
  미로는 반드시 탈출할 수 있는 형태로 제시됩니다. 
- 이때 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수를 구하세요. 
  칸을 셀 때는 시작 칸과 마지막 칸을 모두 포함해서 계산합니다. 

(입력조건)
- 첫째 줄에 두 정수 N,M ( 4<= N,M <= 200 )이 주어집니다. 다음 N개의 줄에는 각각 M개의 정수
  ( 0 혹은 1 )로 미로의 정보가 주어집니다. 각각의 수들을 공백 없이 붙어서 입력으로 제시됩니다. 
  또한 시작 칸과 마지막 칸은 항상 1입니다. 

(출력조건)
- 첫째 줄에 최소 이동 칸의 개수를 출력합니다. 

# 입력예시 
  5 6 
  101010
  111111
  000001
  111111
  111111
# 출력예시
  10 
--------------------
- BFS는 시작지점에서 가까운 노드부터 차례대로 그래프의 모든 노드를 탐색합니다. ( 간선 비용 같을때 최단 비용 구할때 BFS 사용가능 )
- 상,하,좌,우로 연결된 모든 노드로의 거리가 1로 동일합니다.
  > 따라서 (1,1)지점부터 BFS를 수행하여 모든 노드의 최단 거리 값을 기록하면 해결할 수 있습니다.
"""


# BFS 너비우선탐색 구현
def bfs(x,y):
    # 큐(Queue) 구현을 위해 deque 라이브러리 사용 
    queue = deque()
    queue.append((x,y))
    # 큐가 빌 때까지 반복하기 
    while queue:
        x,y = queue.popleft()   
        # 상,하,좌,우 방향으로의 위치 확인 
        for i in range(4):
           nx = x + dx[i]
           ny = y + dy[i]
           # 미로 찾기 공간 벗어난 경우 무시 
           if nx < 0 or nx >= n or ny < 0 or ny >= m:
               continue
           # 벽(0)인 경우 무시 
           if graph[nx][ny] == 0 : 
               continue 
           # 해당 노드를 처음 방문하는 경우에만 최단 거리 기록 
           if graph[nx][ny] == 1 : 
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx,ny))

    # 가장 오른쪽 아래까지의 최단 거리 측정 
    return graph[n-1][m-1]    



from collections import deque 

# N, M 을 공백을 기준으로 구분하여 입력 받기 
n,m = map(int, input().split())

graph = []
for i in range(5):
    graph.append(list(map(int, input())))

print(graph)

# 상,하,좌,우 방향정의 
dx = [-1,0,1,0]
dy = [0,-1,0,1]

print(bfs(0,0))

     



"""
# 입력
    5 6
    101010
    111111
    000001
    111111
    111111

# graph
    [
        [1, 0, 1, 0, 1, 0], 
        [1, 1, 1, 1, 1, 1], 
        [0, 0, 0, 0, 0, 1], 
        [1, 1, 1, 1, 1, 1], 
        [1, 1, 1, 1, 1, 1]
    ]

    queue >> deque([(0, 0)]) 
    x,y >> 0,0 
    for문 graph >> [[1, 0, 1, 0, 1, 0], [2, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(1, 0)]) 
    x,y >> 0,0 
    for문 graph >> [[3, 0, 1, 0, 1, 0], [2, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    for문 graph >> [[3, 0, 1, 0, 1, 0], [2, 3, 1, 1, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(0, 0), (1, 1)]) 
    x,y >> 1,0 
    queue >> deque([(1, 1)]) 
    x,y >> 0,0 
    for문 graph >> [[3, 0, 1, 0, 1, 0], [2, 3, 4, 1, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(1, 2)]) 
    x,y >> 1,1 
    for문 graph >> [[3, 0, 5, 0, 1, 0], [2, 3, 4, 1, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    for문 graph >> [[3, 0, 5, 0, 1, 0], [2, 3, 4, 5, 1, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(0, 2), (1, 3)]) 
    x,y >> 1,2 
    queue >> deque([(1, 3)]) 
    x,y >> 0,2 
    for문 graph >> [[3, 0, 5, 0, 1, 0], [2, 3, 4, 5, 6, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(1, 4)]) 
    x,y >> 1,3 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 1], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(0, 4), (1, 5)]) 
    x,y >> 1,4 
    queue >> deque([(1, 5)]) 
    x,y >> 0,4 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(2, 5)]) 
    x,y >> 1,5 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 1, 1, 9], [1, 1, 1, 1, 1, 1]] 
    queue >> deque([(3, 5)]) 
    x,y >> 2,5 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 1, 10, 9], [1, 1, 1, 1, 1, 1]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 1, 10, 9], [1, 1, 1, 1, 1, 10]] 
    queue >> deque([(3, 4), (4, 5)]) 
    x,y >> 3,5 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 11, 10, 9], [1, 1, 1, 1, 1, 10]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 1, 11, 10, 9], [1, 1, 1, 1, 11, 10]] 
    queue >> deque([(4, 5), (3, 3), (4, 4)]) 
    x,y >> 3,4 
    queue >> deque([(3, 3), (4, 4)]) 
    x,y >> 4,5 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 12, 11, 10, 9], [1, 1, 1, 1, 11, 10]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 1, 12, 11, 10, 9], [1, 1, 1, 12, 11, 10]] 
    queue >> deque([(4, 4), (3, 2), (4, 3)]) 
    x,y >> 3,3 
    queue >> deque([(3, 2), (4, 3)]) 
    x,y >> 4,4 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 13, 12, 11, 10, 9], [1, 1, 1, 12, 11, 10]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [1, 13, 12, 11, 10, 9], [1, 1, 13, 12, 11, 10]] 
    queue >> deque([(4, 3), (3, 1), (4, 2)]) 
    x,y >> 3,2 
    queue >> deque([(3, 1), (4, 2)]) 
    x,y >> 4,3 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [14, 13, 12, 11, 10, 9], [1, 1, 13, 12, 11, 10]] 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [14, 13, 12, 11, 10, 9], [1, 14, 13, 12, 11, 10]] 
    queue >> deque([(4, 2), (3, 0), (4, 1)]) 
    x,y >> 3,1 
    queue >> deque([(3, 0), (4, 1)]) 
    x,y >> 4,2 
    for문 graph >> [[3, 0, 5, 0, 7, 0], [2, 3, 4, 5, 6, 7], [0, 0, 0, 0, 0, 8], [14, 13, 12, 11, 10, 9], [15, 14, 13, 12, 11, 10]] 
    queue >> deque([(4, 1), (4, 0)]) 
    x,y >> 3,0 
    queue >> deque([(4, 0)]) 
    x,y >> 4,1 
    while문 밖이다
    
    최종결과 : 
    [
     [3, 0, 5, 0, 7, 0], 
     [2, 3, 4, 5, 6, 7], 
     [0, 0, 0, 0, 0, 8], 
     [14, 13, 12, 11, 10, 9], 
     [15, 14, 13, 12, 11, 10]
    ]
    
    10

"""









