[파이썬 문법 - 사전, 집합 자료형] https://youtu.be/Mkk8WOCAlqQ

* 사전 자료형 
- 키(Key)와 값(Value)의 쌍을 데이터로 가지는 자료형 
- 키와 값의 쌍을 데이터로 가지며, 원하는 '변경 불가능한(Immutable) 자료형'을 
  키로 사용 할 수 있음
- 파이썬의 사전 자료형은 해시 테이블(Hash Table)을 이용하므로
  '데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리'할 수 있음 

```
data = dict()
data['사과'] = 'apple'
data['바나나'] = 'banana'
data['코코넛'] = 'coconut'

print(data)

if '사과' in data:
   print("'사과'를 키로 가지는 데이터가 존재함")


## 결과1 
{'사과': 'apple', '바나나': 'banana', '코코넛': 'coconut'}
'사과'를 키로 가지는 데이터가 존재함

# 키 데이터만 담은 리스트 
key_list = data.keys()
# 값 데이터만 담은 리스트
value_list = data.values()

print(key_list)
print(value_list)


# 각 키에 따른 값을 하나씩 출력 
for key in key_list:
    print(data[key])


## 결과 2 
dict_keys(['사과', '바나나', '코코넛'])
dict_values(['apple', 'banana', 'coconut'])
apple
banana
coconut

```

※ 사전 자료형 관련 메소드 
- keys()함수 : 키 데이터만 뽑아서 리스트로 이용할 때 씀 
- values()함수 : 값 데이터만 뽑아서 리스트로 이용할 때 씀 

```
a = dict()
# 초기화 1
a['홍길동'] = 98
a['이순신'] = 90

print(a)

# 초기화 2
b = {
    '홍길동' : 98,
    '이순신' : 90
}

print(b)
print(b['이순신'])

# dict_keys 객체형태로 반환되기 때문에 list로 형 변환 시킴 
key_list = list(b.keys())
print(key_list)


## 결과 
{'홍길동': 98, '이순신': 90}
{'홍길동': 98, '이순신': 90}
90
['홍길동', '이순신']
```





* 집합 자료형 
- 특) 중복을 허용하지 않음, 순서가 없음 
- 집합은 리스트 혹은 문자열을 이용해서 초기화할 수 있음 
  > 이때 set()함수를 이용함 
- 혹은 중괄호({})안에 각 원소를 콤마(,)를 기준으로 구분하여 삽입함으로써 초기화 할 수 있음 
- '데이터의 조회 및 수정에 있어서 O(1)의 시간에 처리'할 수 있음 

```
# 집합 자료형 초기화 방법 1 ( 중복 제거됨 )
data = set([1,1,2,3,4,4,5])
print(data)

# 집합 자료형 초기화 방법 2 
data = {1,1,2,3,4,4,5}
print(data)

## 결과
{1, 2, 3, 4, 5}
{1, 2, 3, 4, 5}

```

- 기본적인 집합 연산으로 합집합, 교집합, 차집합 있음 
```
a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

# 합집합 
print(a|b)

# 교집합 
print(a&b)

# 차집합 
print(a-b)

## 결과 
{1, 2, 3, 4, 5, 6, 7}
{3, 4, 5}
{1, 2}

```

```
data = set([1,2,3])
print(data)

# 새로운 원소 추가 
data.add(4)
print(data)

# 새로운 원소 여러개 추가 
data.update([5,6])
print(data)

# 특정한 값을 갖는 원소 삭제 
data.remove(3)
print(data)

## 결과 
{1, 2, 3}
{1, 2, 3, 4}
{1, 2, 3, 4, 5, 6}
{1, 2, 4, 5, 6}

```


※ 사전 과 집합 자료형의 특징 
- 리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있음 
- 사전 자료형과 집합 자료형은 '순서가 없기 때문에' 인덱싱으로 값을 얻을 수 없음 
  > 사전의 키(Key) 혹은 집합의 원소(Element)를 이용해 O(1)의 시간 복잡도로 조회함 //상수 시간만큼 걸림
  
