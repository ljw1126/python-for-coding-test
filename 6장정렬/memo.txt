[ 정렬(Sorting) 알고리즘 ]
    - 정렬(Sorting)이란 '데이터를 특정한 기준에 따라 순서대로 나열'하는 것을 말합니다. 
    - 일반적으로 문제 상황에 따라서 적절한 정렬 알고리즘이 공식처럼 사용됩니다. 

1. 선택 정렬 
    - 처리되지 않은 데이터 중에서 
      '가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸는 것을 반복'합니다. 
    - 선택 정렬은 N번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 합니다. 
    - 구현 방식에 따라서 사소한 오차는 있을 수 있지만, 전체 연산 횟수는 다음과 같습니다. 
        N + (N-1) + (N-2) + ... + 2
    - 이는 (N^2 + N - 2) / 2 로 표현할 수 있는데, 빅오 표기법에 따라서 O(N^2)이라고 작성합니다. 


2. 삽입 정렬 
    - 처리되지 않은 데이터를 하나씩 골라 '적절한 위치에 삽입'합니다.
    - 선택 정렬에 비해 구현 난이도가 높은 편이지만, 일반적으로 더 효율적으로 동작함 
    // 매번 왼쪽에 데이터와 비교해서 적절한 위치에 삽입 
    - 삽입 정렬의 시간 복자도는 O(N^2)이며, 선택 정렬과 마찬가지로 반복문이 두 번 중첩되어 사용됩니다. 
    - 삽입 정렬은 '현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작'합니다. 
    // 이중 for문 사용시 N^2만 나오지 않음 
      > 최선의경우 O(N)의 시간 복잡도를 가집니다. 


3. 퀵 정렬  // 표준으로 사용할 수 있는 정렬 알고리즘  
    - '기준 데이터를 설정'하고 그 '기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법'입니다.
    - 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나입니다. 
    - 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘 입니다. 
    - 가장 기본적인 퀵 정렬은 '첫 번째 데이터를 기준 데이터(Pivot)로 설정'합니다.
    // ※ 피벗(기준값) , 왼쪽에서 피벗보다 큰 데이터를 선택, 오른쪽에서는 피벗보다 작은값 선택 후 스왑함 
    - 퀵 정렬은 평균의 경우 O(NlogN)의 시간 복잡도를 가집니다.
      하지만 최악의 경우 O(N^2)의 시간 복잡도를 가집니다. 
      > 첫 번째 원소를 피벗으로 삼을때, 이미 정렬된 배열에 대해서 퀵 정렬을 수행하면 어떻게 될까요?
        0 1 2 3 4 5 6 7 8 9


4. 계수(Counting) 정렬 
    - 특정한 조건이 부합할 때만 사용할 수 있지만 '매우 빠르게 동작하는' 정렬 알고리즘입니다.
      > 계수 정렬은 '데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때' 사용가능함 
    - 데이터 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행시간 O(N+K)를 보장함
    - 계수 정렬의 시간 복잡도와 공간 복잡도는 모두 O(N+K)입니다. 
    - 계수 정렬은 때의 따라서 심각한 비효율성을 초래할 수 있습니다. 
      > 데이터가 0과 999,999로 단 2개만 존재하는 경우를 생각해 봅시다.
        >> 100만개 만큼의 원소가 담길수 있는 배열을 만들어야 하니, 사용하기 어렵다
    - 계수 정렬은 '동일한 값을 가지는 데이터가 여러개 등장할 때' 효과적으로 사용할 수 있습니다. 
      > 성적의 경우 100점을 맞은 학생이 여러 명일 수 있기 때문에 계수 정렬이 효과적입니다. 

※ 25강에 정렬 알고리즘별 복잡도와 특징 정리한 표가 나옴 


