
* 빅오 표기법(Big-O Notation)
- 가장 빠르게 증가하는 항만을 고려하는 표기법 
  > 함수의 상한만을 나타냄 
- 예로 연산 횟수가 3N^3 + 5N^2 + 1,000,000 인 알고리즘이 있다고 하면 
  > 빅오 표기법에서는 차수가 가장 큰 항만 남기므로 O(N^3)으로 표현됨 


※ 알고리즘 성능 
순위 | 명칭 
O(1)  상수시간(Constant time)   ---------- 좋음 
O(logN) 로그 시간(Log time)
O(N) 선형시간(Linear time)
O(NlogN) 로그 선형시간 
O(N^2) 이차 시간 
O(N^3) 삼차 시간
O(2^n) 지수 시간                 --------- 나쁨 


※ 알고리즘 설계 tip 
- 일반적으로 cpu 기반의 개인 컴퓨터나 채점용 컴퓨터에서 연산 횟수가 5억 초과하는 경우 
  > C 언어 기준으로 통산 1~3초 가량 시간 소요됨 
  > Python 기준으로 통산 5~15초 가량의 시간 소요됨 
    >> PyPy의 경우 때때로 C언어보다도 빠르게 동작하기도 함 

- O(N^3)의 알고리즘을 설계한 경우, N의 값이 5,000이 넘는다면 얼마나 걸릴까요?
- **코딩 테스트 문제에서 시간제한은 통산 1~5초 가량이라는 점에 유의할 것 ! 
  > 혹여 문제에 명시되어 있지 않는 경우 대략 5초 정도라고 생각하고 문제 푸는 것이 합리적임 


※ 요구사항에 따라 적절한 알고리즘 설계하기 ( 스스로 감을 찾아 나가는게 좋음 ! )
- 문제에서 가장 먼저 확인해야 하는 내용은 '시간제한(수행시간 요구사항)' 이다. 
- 시간제한이 1초인 문제를 만났을 때, 일반적인 기준은 다음과 같습니다. 
  > N의 범위가 500인 경우 : 시간 복잡도가 O(N^3)인 알고리즘을 설계하면 문제 풀 수 있음
  > N의 범위가 2,000인 경우 : 시간 복잡도가 O(N^2)인 알고리즘을 설계하면 문제 풀 수 있음
  > N의 범위가 100,000인 경우 : 시간 복잡도가 O(NlogN)인 알고리즘을 설계하면 문제 풀 수 있음
  > N의 범위가 10,000,000인 경우 : 시간 복잡도가 O(N)인 알고리즘을 설계하면 문제 풀 수 있음

※ 알고리즘 문제 해결 과정 
- 일반적인 알고리즘 문제 해결 과정은 다음과 같습니다. 
  1. 지문 읽기 및 컴퓨터적 사고 
  2. 요구사항(복잡도) 분석***
  3. 문제 해결을 위한 아이디어 찾기 
  4. 소스코드 설계 및 코딩 
- 일반적으로 대부분의 문제 출제자들은 핵심 아이디어를 캐치한다면, 
  간결하게 소스코드를 작성할 수 있는 형태로 문제를 출제함 ! 


  ※ 수행시간 측정 소스코드 예제 
  ```
  import time 
  start_time = time.time() # 측정 시작 
  
  ...
  
  end_time = time.time()  # 측정 종료
  print("time:", end_time - start_time) #수행 시간 출력 

  ```

  ※ 파이썬 input() 대신  sys.stdin.readline() 사용하기 ! 
  import sys 

  n = int(sys.stdin.readline())
  array = []

  for _ in range(n):
      array.append(list(map(int, sys.stdin.readline().split())))

  for i in array:
      print(i[0] + i[1])